| 2026-02-14 | static 메서드1 | public=공개여부, static=메모리 할당. / staic이어도 접근제어자로 막혀있으면 사용 불가 |
|            | static 메서드2 | static 메서드는 static만 사용 할 수 있다. '클래스 내부에서'
|            |                |(클래스 내부에서) '본인이 static이면' ⚠️static으로 된 변수나 메서드만 참조 가능⚠️|
|            |                | 1. 프로그램 시작 → static 메모리에 올라감 |
|            |                | 2. new 실행 → 그때서야 일반 변수/메서드 생김 |
|            |                | 3. static은 1번 시점에 이미 있는데, 2번이 아직 안 일어났을 수 있으니까 참조 불가 |
|            |                | but. static은 인스턴스 변수를 모르지만, 매개변수로 객체를 직접 전달하면 사용 가능 |
|            | static 메서드3 | import satatic = 정적메서드 자체를 사용할것이라고 선언 => 메소드 호출시 '클래스.메소드명' 하지 않고 바로 '메소드명 호출' 가능
|            |                | import static 패키지 위치.메소드 => 정적메소드 사용 => 바로 '메소드명()' 호출 가능.
|            |                | import static 패키지위치.클래스명.* => 바로 해당 클래스 내의 모든 메소드호출 사용가능.
|            | 연슴문제&풀이1 | <img width="584" height="657" alt="image" src="https://github.com/user-attachments/assets/27113ba7-f3ca-4489-b0b6-313dd96f9e47" />
|            | 연습문제&풀이2 |<img width="956" height="1095" alt="image" src="https://github.com/user-attachments/assets/13f20d16-00d1-4ae8-99fb-3ac33c3c06cf" />

| 2026-02-15 |    final 변수  | final = 최초 한번만 값 할당 가능 (값 변경 불가) 
|            |                 | 단. 매개변수가 final이고 호출되어 힐딩되는 매개변수가 객체 일 경우 아래처럼 할당됨.
|            |                 | ex =>Dog a = new Dog(10); Dog b = new Dog(30); 이 둘이 매개변수로 가능. 단 한번 정해지면 변경 불가.
|            |       상수      | 상수(static final) 관례 = '대문자사용', '_(언더바)로 구분'
|            |final 변수와 참조| final 참조 변수는 참조하는 대상(주소)을 고정할 뿐, 참조하는 객체의 내부 상태(값)까지 제한하지 않는다.
|            |                 |예를 들어 data.value = 10, data.value = 20, data.value = 30 등은 얼마든지 가능.
|            |    상속 개념    | 상속 =무조건 단일상속. 자식클래스킄 부모기능을 물려받는다.
|            |                 | 1. 상속관계의 객체 생성 -> 부모와 자식모두 (각각) 생성됨. 
|            |                 | 2. (조건:오버라이딩X)상속관계의 객체를 호출시 ->'대상 타입 정하기'
|            |                 | 3. 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾는다. (찾지 못할 시 컴파일 오류 발생.)
|            |상속과 오버라이딩| *에노테이션 = @ (프로그램이 읽을 수 있는 주석)
|            | 오버라이딩 조건 | 1. 메서드의 '이름' '매개변수' '반환타입' 이 같을것. 
|            |                 | 2. 자식 클래스의 접근제어자는 부모 클래스와 같거나 확장일 것.
|            |                 | 3. 부모 클래스보다 더 많은 체크, 예외 throw 할 수 없다.
|            |                 | 4. static, final, private 메서드는 오버라이딩 할 수 없다
|            |                 | 5. 생성자는 오버라이딩 할 수 없다.
|            | 상속과 접근제어 | protected = 패키지가 달라도 상속관계라면 허용.
|            |super(부모 참조)| this.변수명 = 나의(자식 본인)클래스 / super.변수명 = 부모클래스. 
|            |  super(생성자)  |상속관계시 자식클래스의 생성자에서 "부모클래스의 생성자를 '반드시' 호출"
|            |                 | => 상속관계에서 부모 생성자 호출 = super(); 사용. ( 부모 클래스의 생성자가 매개변수 없는 기본생성자라면 생략 가능.) /**자식 생성자 첫 줄에 부모생성자 적기**
|            | *상속객체 순서* | 1. 부모 세팅 (부모 생성자 실행)
|            |                 | 2. 자식 세팅 (자식 생성자 실행)
|            |                 | 3. 외부에서 자식 호출 → 자식에 없으면 부모 것 사용 (=자식 클래스에 부모생성자 필수)

| 2026-02-17 |  다형성 참조&캐스팅 | parant parant = new child -> "부모타입의 변수에 자식의 주솟값을 넣는다." 
다형성 참조를 쓰는 이유 | 
인터페이스,추상 : **부모타입의 기능만 사용이 호출 가능하지만 부모타입의 기능은 깡통임. 실체 코드는 자식이 갖고있으나 자식의 주솟값이 없으면 부모로 호출되어도 어느 자식으로 호출될지 알지 못함**
일반클래스,추상 : **일반부모 클래스에 실제 코드가 있어도 결국엔 자식으로 가서 확장된 기능으로 덮어 씌워진. 그러니까 오버라이딩 된 기능을 쓰려고 자식의 주소값을 담는다**
캐스팅을 쓰는 이유 | **부모 코드에는 없는 자식의 기능을, 객체 생성 시 연결된 '주솟값'을 이정표 삼아 실시간으로 찾아가 실행하는 메커니즘**
